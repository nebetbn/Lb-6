#include <iostream>
#include <string>
#include <vector>
#include <numeric> // Not directly used in this solution, but often useful.

int main() {
    // Прискорюємо ввід/вивід для ефективності,
    // щоб уникнути Time Limit Exceeded на великих вхідних даних.
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    std::string s;
    std::cin >> s; // Зчитуємо вхідний рядок S

    int n = s.length(); // Отримуємо довжину рядка S

    // Якщо рядок порожній, або має довжину 1, найбільша грань дорівнює 0.
    // За умовою задачі, 1 <= length(S) <= 100000, тому рядок не може бути порожнім.
    if (n == 0) {
        std::cout << 0 << std::endl;
        return 0;
    }

    // Вектор для зберігання pi-функції (префікс-функції)
    // pi[i] зберігає довжину найдовшого власного префікса підрядка s[0...i],
    // який також є суфіксом цього підрядка.
    std::vector<int> pi(n);
    pi[0] = 0; // Для першого символу (підрядок довжини 1), найдовший власний префікс-суфікс має довжину 0.

    // Обчислення pi-функції за алгоритмом КМП
    for (int i = 1; i < n; ++i) {
        int j = pi[i - 1]; // Починаємо з довжини попереднього найбільшого префікса-суфікса

        // Якщо поточний символ s[i] не збігається з символом s[j] (наступним символом префікса),
        // переходимо до меншого префікса-суфікса для порівняння.
        while (j > 0 && s[i] != s[j]) {
            j = pi[j - 1];
        }

        // Якщо символи збігаються, збільшуємо довжину префікса-суфікса
        if (s[i] == s[j]) {
            j++;
        }

        pi[i] = j; // Зберігаємо обчислене значення pi[i]
    }

    // Найдовша грань всього рядка S - це значення pi-функції для його останнього символу.
    // pi[n-1] містить довжину найдовшого власного префікса всього рядка S,
    // який також є його суфіксом.
    std::cout << pi[n - 1] << std::endl; // Виводимо результат

    return 0;
}
